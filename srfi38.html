<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>
  <head>
    <title>SRFI 38: External Representation for Data With Shared Structure</title>
  </head>

  <body>

<H1>Title</H1>

External Representation for Data With Shared Structure

<H1>Author</H1>

Ray Dillinger

<H1>Abstract</H1>
<P>
This SRFI proposes (write-showing-shared), a procedure for writing data  
with shared structure, both so that sufficient information to recover eq? 
relationships between shared parts of structure exists, and so that 
there is a standard method for printing such objects which is guaranteed 
not to go into an infinite loop. 
</P>
<P>
This SRFI permits but does not require replacing the standard <tt>(write)</tt> 
function, because the standard print function may be implemented with 
better efficiency.  An implementation conforms to this SRFI if it 
provides a function named <tt>(write-showing-shared)</tt>, which produces 
the same notation as produced by the reference implementation and which is 
guaranteed to terminate in finite time given a finite structure to print.

</P>


<H1>Issues</H1>

<P>
The initial draft does not say anything about the interaction of <tt>(read) </tt>
and the external representations generated by <tt>(write-showing-shared)</tt>.  
Should it be required that <tt>(read)</tt> be extended to correctly read and 
parse the extended external representations, or should a second form for 
reading such as <tt>(read-with-shared-structure)</tt> be specified?  It 
seems to me that there is a stronger case for extending the <tt>(read)</tt> 
function than there was for the <tt>(write)</tt> function since it is more 
plausible that something unexpected will be read than written. 
</P>

<H1>Rationale</H1>

R5RS scheme and IEEE scheme provide the procedure (write), which prints 
machine-readable representations of lists and other objects.  However, 
the printed representation does not preserve information about what 
parts of the structure are shared, and in the case of self-referential 
objects the behavior of (write) itself is undefined; it is permitted 
to go into an infinite loop or invoke the dreaded curse of the nasal 
demons.
</P>
<P>
For example, it is possible to have a list within which two or more 
members are the same string (in the sense of eq?), but when the list 
is written, there is not sufficient information in the representation to 
recover the (eq?) relationship.  When the list is read back in, there 
will be two or more copies of the string which are (eqv?) but not (eq?).
</P>
<P>
As an example of the second problem,  The results of evaluating
<PRE>
(begin (define a (cons 'val1 'val2))
       (set-cdr! a a)
       (write a))
</PRE>
are undefined; in R5RS parlance, calling write on such a structure "is an 
error", but not one that is necessarily signalled. The routine is permitted 
to print a nonstandard notation such as the one proposed in this standard or 
a different one, fail silently, signal an error, go into an infinite loop, 
or make demons fly out of your nose.  Some of these results are unacceptable 
in some cases. This SRFI hopes to provide a standard way of dealing with this 
problem by providing a method of writing data which is guaranteed to 
be well-behaved and predictable even on data containing shared structures.
</P>

<P>
The extended functionality described below in the implementation of 
<tt>(write-showing-shared)</tt>is already present in the <tt>(write)</tt>
function of several major scheme implementations (PLT, SISC, Chez, 
Bigloo, MIT scheme, and possibly others). 
</P>

<H1>Specification</H1>
<P>
Implementations conforming to this SRFI will provide a procedure named 
<tt>(write-showing-shared)</tt>, which is capable of writing an external 
representation for any data object which has an external representation 
under the <tt>(write)</tt> procedure.  The external representations generated by 

<tt>(write-showing-shared)</tt> must indicate all eq? 
relationships in the data object being written, and <tt>(write-showing-shared)</tt>
must terminate in finite time when printing any data object which can be stored 
in finite memory. 
</P>
<P>
When <tt>(write-showing-shared)</tt> writes an object for the first time, it 
is written exactly as though it had been written using the procedure (write) 
if no further occurrences of it appear in the structure being written.  If 
further occurrences of it appear in the structure being written, the object 
must be marked by a preceding #NN= notation, where NN is a unique natural 
number.  Further occurrences of the same object in writing the structure are 
then represented by #NN#, where N is again replaced by the natural number 
designating that object.
</P>
<P>
For example, the code 
<PRE>

(begin (define a (cons 'val1 'val2))
       (set-cdr! a a)
       (write-showing-shared a))

</PRE>
should produce the output <tt> #1=(val1 . #1#) </tt>.  This shows a cons 
cell whose cdr contains itself.  


<H1>Implementation</H1>
<P>
This implementation was originally posted by Al Petrofsky to comp.lang.scheme 
in article 87pu2b9ykj.fsf@radish.petrofsky.org, on 11 March 2002. It is used 
here with his generous permission.
</P>

<PRE>
;;; A printer that shows all sharing of substructures.  Uses the Common
;;; Lisp print-circle notation: #n# refers to a previous substructure
;;; labeled with #n=.  Returns a string rather than printing anything.
;;; Takes O(n^2) time. 

(define (write-showing-shared obj)
  (define (acons key val alist)
    (cons (cons key val) alist))
  ;; We only track duplicates of pairs, vectors, and strings.  We
  ;; ignore zero-length vectors and strings because r5rs doesn't
  ;; guarantee that eq? treats them sanely (and they aren't very
  ;; interesting anyway).
  (define (interesting? obj)
    (or (pair? obj)
        (and (vector? obj) (not (zero? (vector-length obj))))
        (and (string? obj) (not (zero? (string-length obj))))))
  ;; COLLECT conses strings onto the front of list L to get L*.  When
  ;; the strings are concatenated in reverse order, they yield the
  ;; printed representation of OBJ.
  ;; ALIST has an entry for each interesting part of OBJ.  The
  ;; associated value will be:
  ;;  -- a number if the part has been given one,
  ;;  -- #t if the part will need to be assigned a number but has not been yet,
  ;;  -- #f if the part will not need a number.
  ;; The cdr of ALIST's first element should be the most recently
  ;; assigned number.
  ;; Returns (K L* ALIST*), where ALIST* is ALIST with new shadowing
  ;; entries for any parts that had numbers assigned.
  (define (collect obj l alist k)
    (define (collect-interesting l alist)
      (cond ((pair? obj)
             (collect (car obj) (cons "(" l) alist
                      (lambda (l alist)
                        (let collect-cdr ((obj (cdr obj)) (l l) (alist alist))
                          (cond ((and (pair? obj) (not (cdr (assq obj alist))))
                                 (collect (car obj) (cons " " l) alist
                                          (lambda (l alist) 
                                            (collect-cdr (cdr obj) l alist))))
                                ((null? obj) (k (cons ")" l) alist))
                                (else
                                 (collect obj (cons " . " l) alist
                                          (lambda (l alist)
                                            (k (cons ")" l) alist)))))))))
            ((vector? obj)
             (let ((len (vector-length obj)))
               (collect (vector-ref obj 0) (cons "#(" l) alist
                        (lambda (l alist)
                          (let collect-vec ((i 1) (l l) (alist alist))
                            (if (= i len)
                                (k (cons ")" l) alist)
                                (collect (vector-ref obj i) (cons " " l) alist
                                         (lambda (l alist)
                                           (collect-vec (+ i 1)
                                                        l alist)))))))))
            (else
             ;; If a string contains any double-quotes or backslashes
             ;; then we must construct a new string with escape
             ;; sequences.  Otherwise, we can use the string as-is.
             (let ((len (string-length obj)))
               (let check-for-special-chars ((i 0))
                 (if (= i len)
                     (k `("\"" ,obj "\"" . ,l) alist)
                     (case (string-ref obj i)
                       ((#\\ #\")
                        (k (cons (apply string #\"
                                        (do ((i (- len 1) (- i 1))
                                             (l '(#\")
                                                (let* ((c (string-ref obj i))
                                                       (l (cons c l)))
                                                  (case c
                                                    ((#\\ #\") (cons #\\ l))
                                                    (else l)))))
                                            ((< i 0) l)))
                                 l)
                           alist))
                       (else (check-for-special-chars (+ i 1))))))))))
    (if (interesting? obj)
        (let ((val (cdr (assq obj alist))))
          (cond ((not val) (collect-interesting l alist))
                ((number? val) (k `("#" ,(number->string val) "#" . ,l) alist))
                (else
                 (let ((n (+ 1 (cdar alist))))
                   (collect-interesting `("=" ,(number->string n) "#" . ,l)
                                        (acons obj n alist))))))
        (k (cons (cond ((input-port? obj) "#<input-port>")
                       ((output-port? obj) "#<output-port>")
                       ((eof-object? obj) "#<eof-object>")
                       ((procedure? obj) "#<procedure>")
                       ((number? obj) (number->string obj))
                       ((symbol? obj) (symbol->string obj))
                       ((boolean? obj) (if obj "#t" "#f"))
                       ((null? obj) "()")
                       ((string? obj) "\"\"")
                       ((vector? obj) "#()")
                       ((char? obj) (case obj
                                      ((#\newline) "#\\newline")
                                      ((#\space) "#\\space")
                                      (else (string #\# #\\ obj))))
                       (else "#<unknown>"))
                 l)
           alist)))
  ;; Scan computes the initial value of the alist, which maps each
  ;; interesting part of the object to #t if it occurs multiple times,
  ;; #f if only once.
  (define (scan obj alist)
    (cond ((not (interesting? obj)) alist)
          ((assq obj alist)
           => (lambda (p)
                (if (cdr p)
                    alist
                    (acons obj #t alist))))
          (else
           (let ((alist (acons obj #f alist)))
             (cond ((pair? obj) (scan (car obj) (scan (cdr obj) alist)))
                   ((vector? obj)
                    (let ((len (vector-length obj)))
                      (do ((i 0 (+ 1 i))
                           (alist alist (scan (vector-ref obj i) alist)))
                          ((= i len) alist))))
                   (else alist))))))
  (collect obj '() (acons 'dummy 0 (scan obj '()))
           (lambda (l alist)
             (display (apply string-append (reverse l))))))
</PRE>


<H1>Copyright</H1>
Copyright (C) Ray Dillinger 2003. All Rights Reserved. 
<p>
This document and translations of it may be copied and furnished to
others, and derivative works that comment on or otherwise explain it
or assist in its implementation may be prepared, copied, published and
distributed, in whole or in part, without restriction of any kind,
provided that the above copyright notice and this paragraph are
included on all such copies and derivative works. However, this
document itself may not be modified in any way, such as by removing
the copyright notice or references to the Scheme Request For
Implementation process or editors, except as needed for the purpose of
developing SRFIs in which case the procedures for copyrights defined
in the SRFI process must be followed, or as required to translate it
into languages other than English.
<p>
The limited permissions granted above are perpetual and will not be
revoked by the authors or their successors or assigns.
<p>
This document and the information contained herein is provided on an
"AS IS" basis and THE AUTHOR AND THE SRFI EDITORS DISCLAIM ALL
WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A
PARTICULAR PURPOSE.


    <hr>
    <address>Editor: <a href="mailto:srfi-editors@srfi.schemers.org">Dave 

Mason</a></address>
<!-- Created: Tue Sep 29 19:20:08 EDT 1998 -->
<!-- hhmts start -->
Last modified: Mon Dec 16 00:08:06 GMT 2002
<!-- hhmts end -->
  </body>
</html>
